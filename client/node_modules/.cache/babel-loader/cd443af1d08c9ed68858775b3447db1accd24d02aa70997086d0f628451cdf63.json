{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Usuario\\\\Desktop\\\\Programacion\\\\Project-Weather\\\\client\\\\src\\\\App.js\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useEffect } from 'react';\nimport './App.css';\nimport Cards from './components/Cards.jsx';\nimport Nav from './components/Nav.jsx';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction App() {\n  _s();\n\n  /* ciudades empieza como arreglo vacío */\n  const [cities, setCities] = useState([]);\n  let apiKey = '4ae2636d8dfbdc3044bede63951a019b';\n  useEffect(() => {\n    const citiesSaved = JSON.parse(window.localStorage.getItem('My cities'));\n\n    if (citiesSaved) {\n      setCities(citiesSaved);\n    }\n  }, []);\n  useEffect(() => {\n    window.localStorage.setItem('My cities', JSON.stringify(cities));\n  }, [cities]);\n  /* Se puede usar axios pero tene que importarlo. */\n\n  function onSearch(ciudad) {\n    fetch(`http://api.openweathermap.org/data/2.5/weather?q=${ciudad}&appid=${apiKey}&units=metric`)\n    /* hace el pedido de fetch. El fetch no lo tenes que importar pq es parte de JS */\n    .then(r => r.json())\n    /* transforma a jason la respuesta */\n    .then(recurso => {\n      if (cities.find(c => c.id === recurso.id)) {\n        alert('You have already selected this city.');\n        return;\n      }\n\n      if (recurso.main !== undefined) {\n        /* si existe se crea un objeto con su info. Formatea sus datos y luego lo guarda en las ciudades. */\n        const ciudad = {\n          temp: Math.round(recurso.main.temp),\n          min: Math.round(recurso.main.temp_min),\n          max: Math.round(recurso.main.temp_max),\n          img: recurso.weather[0].icon,\n          id: recurso.id,\n          name: recurso.name,\n          weather: recurso.weather[0].main,\n          humidity: recurso.main.humidity,\n          lon: recurso.coord.lon,\n          lat: recurso.coord.lat,\n          description: recurso.weather[0]\n        };\n        setCities(previousCities => [...previousCities, ciudad]);\n        /* agrega la ciudad formateada al arreglo de ciudades */\n      } else {\n        alert('Ciudad no encontrada');\n      }\n    });\n  }\n\n  function onClose(id) {\n    setCities(previousCities => previousCities.filter(ciudad => ciudad.id !== id)\n    /* tiene que recibir lo q se llama el estado anterior. Le podes poner cualquier nombre (previousCities). Cuando hay que identificar algo, lo mejor es ir por su id (si es q lo tiene) */\n    );\n  } // Move city:\n\n\n  const handleOnDragEnd = result => {\n    if (!result.destination) return;\n    const items = Array.from(cities);\n    const [reorderedItem] = items.splice(result.source.index, 1);\n    items.splice(result.destination.index, 0, reorderedItem);\n    setCities(items);\n  };\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"App\",\n    children: [/*#__PURE__*/_jsxDEV(Nav, {\n      onSearch: onSearch\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 79,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Cards, {\n      cities: cities,\n      onClose: onClose,\n      handleOnDragEnd: handleOnDragEnd\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 81,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 78,\n    columnNumber: 5\n  }, this);\n}\n\n_s(App, \"UtFDQT3EIws3THEJkYkMoyhXxu4=\");\n\n_c = App;\nexport default App;\n\nvar _c;\n\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","Cards","Nav","App","cities","setCities","apiKey","citiesSaved","JSON","parse","window","localStorage","getItem","setItem","stringify","onSearch","ciudad","fetch","then","r","json","recurso","find","c","id","alert","main","undefined","temp","Math","round","min","temp_min","max","temp_max","img","weather","icon","name","humidity","lon","coord","lat","description","previousCities","onClose","filter","handleOnDragEnd","result","destination","items","Array","from","reorderedItem","splice","source","index"],"sources":["C:/Users/Usuario/Desktop/Programacion/Project-Weather/client/src/App.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport './App.css';\nimport Cards from './components/Cards.jsx';\nimport Nav from './components/Nav.jsx';\n\nfunction App() {\n  /* ciudades empieza como arreglo vacío */\n  const [cities, setCities] = useState([]);\n  let apiKey = '4ae2636d8dfbdc3044bede63951a019b';\n\n  useEffect(() => {\n    const citiesSaved = JSON.parse(window.localStorage.getItem('My cities'));\n    if (citiesSaved) {\n      setCities(citiesSaved);\n    }\n  }, []);\n\n  useEffect(() => {\n    window.localStorage.setItem('My cities', JSON.stringify(cities));\n  }, [cities]);\n\n  /* Se puede usar axios pero tene que importarlo. */\n  function onSearch(ciudad) {\n    fetch(\n      `http://api.openweathermap.org/data/2.5/weather?q=${ciudad}&appid=${apiKey}&units=metric`\n    ) /* hace el pedido de fetch. El fetch no lo tenes que importar pq es parte de JS */\n      .then((r) => r.json()) /* transforma a jason la respuesta */\n      .then((recurso) => {\n        if (cities.find((c) => c.id === recurso.id)) {\n          alert('You have already selected this city.');\n          return;\n        }\n\n        if (recurso.main !== undefined) {\n          /* si existe se crea un objeto con su info. Formatea sus datos y luego lo guarda en las ciudades. */\n          const ciudad = {\n            temp: Math.round(recurso.main.temp),\n            min: Math.round(recurso.main.temp_min),\n            max: Math.round(recurso.main.temp_max),\n            img: recurso.weather[0].icon,\n            id: recurso.id,\n            name: recurso.name,\n            weather: recurso.weather[0].main,\n            humidity: recurso.main.humidity,\n            lon: recurso.coord.lon,\n            lat: recurso.coord.lat,\n            description: recurso.weather[0],\n          };\n          setCities((previousCities) => [\n            ...previousCities,\n            ciudad,\n          ]); /* agrega la ciudad formateada al arreglo de ciudades */\n        } else {\n          alert('Ciudad no encontrada');\n        }\n      });\n  }\n\n  function onClose(id) {\n    setCities(\n      (previousCities) =>\n        previousCities.filter(\n          (ciudad) => ciudad.id !== id\n        ) /* tiene que recibir lo q se llama el estado anterior. Le podes poner cualquier nombre (previousCities). Cuando hay que identificar algo, lo mejor es ir por su id (si es q lo tiene) */\n    );\n  }\n\n  // Move city:\n  const handleOnDragEnd = (result) => {\n    if (!result.destination) return;\n    const items = Array.from(cities);\n    const [reorderedItem] = items.splice(result.source.index, 1);\n    items.splice(result.destination.index, 0, reorderedItem);\n    setCities(items);\n  };\n\n  return (\n    <div className=\"App\">\n      <Nav onSearch={onSearch} />\n      {/* le tengo que hacer llegar la función onSearch a Nav para que luego Nav se lo pase a SearchBar. Las propiedades y funciones pasan de padre a hijo para que las puedan usar. Luego la función nieto o lo que sea puede usar la función modificando el estado del componente padre. */}\n      <Cards\n        cities={cities}\n        onClose={onClose}\n        handleOnDragEnd={handleOnDragEnd}\n      />\n      {/* cards recibe un array de ciudades que lo tenemos en cities =  const [cities, setCities] = useState([]);*/}\n    </div>\n  );\n}\n\nexport default App;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}